<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Populate Existing Rooms - MUD Game</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff41;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 { color: #ffff00; text-align: center; }
        .section {
            background: #2a2a2a;
            border: 2px solid #00ff41;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        button {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 3px;
        }
        button:hover { background: #00cc33; }
        button:disabled { background: #666; cursor: not-allowed; }
        .danger { background: #ff4444; }
        .danger:hover { background: #cc0000; }
        #log {
            background: #000;
            color: #00ff41;
            padding: 10px;
            margin: 10px 0;
            height: 500px;
            overflow-y: scroll;
            border: 1px solid #00ff41;
            font-size: 12px;
        }
        #stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .stat-box {
            background: #000;
            padding: 10px;
            border: 1px solid #00ff41;
            border-radius: 3px;
            text-align: center;
        }
        .stat-box h3 { margin: 0; color: #ffff00; font-size: 14px; }
        .stat-box .value { font-size: 24px; font-weight: bold; color: #00ff41; }
        .success { color: #00ff41; }
        .error { color: #ff4444; }
        .info { color: #00d4ff; }
        .warning { color: #ffaa00; }
        .room-list {
            max-height: 300px;
            overflow-y: auto;
            background: #000;
            padding: 10px;
            border: 1px solid #00ff41;
            margin: 10px 0;
        }
        .room-item {
            padding: 5px;
            border-bottom: 1px solid #333;
        }
        .room-item:hover {
            background: #1a3a1a;
        }
    </style>
</head>
<body>
    <h1>üó∫Ô∏è Populate Existing MySQL Rooms</h1>
    
    <div class="section">
        <h2>ÔøΩ API Configuration</h2>
        <p>Your MySQL API requires authentication. Enter your API key:</p>
        <input type="password" id="api-key-input" placeholder="Enter your MySQL API key" style="width: 100%; padding: 10px; background: #000; color: #00ff41; border: 1px solid #00ff41; border-radius: 3px; font-family: 'Courier New', monospace;">
        <p style="font-size: 12px; color: #888; margin-top: 5px;">üí° This is stored in your browser session only, not saved permanently.</p>
    </div>

    <div class="section">
        <h2>ÔøΩüìä Database Statistics</h2>
        <div id="stats">
            <div class="stat-box">
                <h3>Total Rooms</h3>
                <div class="value" id="total-rooms">-</div>
            </div>
            <div class="stat-box">
                <h3>Empty Rooms</h3>
                <div class="value" id="empty-rooms">-</div>
            </div>
            <div class="stat-box">
                <h3>Rooms with NPCs</h3>
                <div class="value" id="rooms-with-npcs">-</div>
            </div>
            <div class="stat-box">
                <h3>Rooms with Monsters</h3>
                <div class="value" id="rooms-with-monsters">-</div>
            </div>
            <div class="stat-box">
                <h3>Rooms with Items</h3>
                <div class="value" id="rooms-with-items">-</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2>üîç Step 1: Analyze Existing Content</h2>
        <button onclick="analyzeRooms()">üì• Load & Analyze All Rooms from MySQL</button>
        <div id="analysis-results" style="margin-top: 10px;"></div>
    </div>

    <div class="section">
        <h2>üéÆ Step 2: Available Content</h2>
        <div id="available-content" style="background: #000; padding: 10px; border: 1px solid #00ff41; margin: 10px 0;">
            <p>Loading available NPCs, monsters, and items...</p>
        </div>
    </div>

    <div class="section">
        <h2>‚öôÔ∏è Step 3: Auto-Populate Empty Rooms</h2>
        <p>Automatically add content to rooms using ONLY existing NPCs, monsters, and items:</p>
        <button onclick="populateEmptyRooms()">ü§ñ Smart Populate Empty Rooms</button>
        <button onclick="populateAllRooms()">üîß Force Populate ALL Rooms (Dangerous)</button>
        <p class="warning" style="font-size: 12px;">‚ö†Ô∏è Force populate will ADD content to ALL rooms, even those with existing content. Use with caution!</p>
        <p class="info" style="font-size: 12px;">‚úì Only uses existing content - no new NPCs/monsters/items will be created</p>
    </div>

    <div class="section">
        <h2>üìú Activity Log</h2>
        <div id="log"></div>
    </div>

    <script type="module">
        const MYSQL_API_URL = 'https://jphsoftware.com/api';
        
        let allRooms = {};
        let allNPCs = {};
        let allMonsters = {};
        let allItems = {};

        function getApiKey() {
            const key = document.getElementById('api-key-input').value.trim();
            if (!key) {
                log('‚ö†Ô∏è Please enter your API key first!', 'error');
                throw new Error('API key required');
            }
            return key;
        }

        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'X-API-Key': getApiKey()
            };
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStats() {
            const totalRooms = Object.keys(allRooms).length;
            const emptyRooms = Object.values(allRooms).filter(r => 
                (!r.npcs || r.npcs.length === 0) && 
                (!r.monsterSpawns || r.monsterSpawns.length === 0) &&
                (!r.items || r.items.length === 0)
            ).length;
            const roomsWithNPCs = Object.values(allRooms).filter(r => r.npcs && r.npcs.length > 0).length;
            const roomsWithMonsters = Object.values(allRooms).filter(r => r.monsterSpawns && r.monsterSpawns.length > 0).length;
            const roomsWithItems = Object.values(allRooms).filter(r => r.items && r.items.length > 0).length;

            document.getElementById('total-rooms').textContent = totalRooms;
            document.getElementById('empty-rooms').textContent = emptyRooms;
            document.getElementById('rooms-with-npcs').textContent = roomsWithNPCs;
            document.getElementById('rooms-with-monsters').textContent = roomsWithMonsters;
            document.getElementById('rooms-with-items').textContent = roomsWithItems;
        }

        window.analyzeRooms = async function() {
            log('Fetching all rooms from MySQL...', 'info');
            
            try {
                const apiKey = getApiKey();
                const response = await fetch(`${MYSQL_API_URL}/rooms`, {
                    headers: { 'X-API-Key': apiKey }
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                allRooms = await response.json();
                log(`‚úì Loaded ${Object.keys(allRooms).length} rooms from MySQL`, 'success');
                
                // Fetch existing NPCs, monsters, items
                const [npcsRes, monstersRes, itemsRes] = await Promise.all([
                    fetch(`${MYSQL_API_URL}/npcs`, { headers: { 'X-API-Key': apiKey } }),
                    fetch(`${MYSQL_API_URL}/monsters`, { headers: { 'X-API-Key': apiKey } }),
                    fetch(`${MYSQL_API_URL}/items`, { headers: { 'X-API-Key': apiKey } })
                ]);

                allNPCs = await npcsRes.json();
                allMonsters = await monstersRes.json();
                allItems = await itemsRes.json();

                log(`‚úì Loaded ${Object.keys(allNPCs).length} NPCs`, 'success');
                log(`‚úì Loaded ${Object.keys(allMonsters).length} monsters`, 'success');
                log(`‚úì Loaded ${Object.keys(allItems).length} items`, 'success');

                // Display available content
                displayAvailableContent();

                updateStats();

                // Show sample of empty rooms
                const emptyRooms = Object.entries(allRooms).filter(([id, r]) => 
                    (!r.npcs || r.npcs.length === 0) && 
                    (!r.monsterSpawns || r.monsterSpawns.length === 0) &&
                    (!r.items || r.items.length === 0)
                );

                const resultsDiv = document.getElementById('analysis-results');
                resultsDiv.innerHTML = `
                    <div class="room-list">
                        <h4>Sample Empty Rooms (showing first 20):</h4>
                        ${emptyRooms.slice(0, 20).map(([id, room]) => `
                            <div class="room-item">
                                <strong>${room.name || id}</strong><br>
                                <span style="color: #888;">${(room.description || '').substring(0, 80)}...</span>
                            </div>
                        `).join('')}
                    </div>
                `;

                log('Analysis complete! Ready to populate rooms.', 'success');
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
            }
        };

        function displayAvailableContent() {
            const contentDiv = document.getElementById('available-content');
            const npcList = Object.keys(allNPCs).join(', ');
            const monsterList = Object.keys(allMonsters).join(', ');
            const itemList = Object.keys(allItems).slice(0, 20).join(', ');
            
            contentDiv.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong style="color: #ffff00;">NPCs (${Object.keys(allNPCs).length}):</strong><br>
                    <span style="color: #888; font-size: 11px;">${npcList || 'None'}</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <strong style="color: #ffff00;">Monsters (${Object.keys(allMonsters).length}):</strong><br>
                    <span style="color: #888; font-size: 11px;">${monsterList || 'None'}</span>
                </div>
                <div>
                    <strong style="color: #ffff00;">Items (${Object.keys(allItems).length}):</strong><br>
                    <span style="color: #888; font-size: 11px;">${itemList || 'None'}${Object.keys(allItems).length > 20 ? '...' : ''}</span>
                </div>
            `;
        }

        window.createBaseNPCs = async function() {
            log('‚ö†Ô∏è This function is deprecated. The tool now uses existing NPCs only.', 'warning');
        };

        window.createBaseMonsters = async function() {
            log('‚ö†Ô∏è This function is deprecated. The tool now uses existing monsters only.', 'warning');
        };

        window.createBaseItems = async function() {
            log('‚ö†Ô∏è This function is deprecated. The tool now uses existing items only.', 'warning');
        };

        window.createAllBaseContent = async function() {
            log('‚ö†Ô∏è This function is deprecated. The tool now uses existing content only.', 'warning');
        };

        window.populateEmptyRooms = async function() {
            log('Starting AI-powered room population...', 'info');
            log('This will analyze room names/descriptions and add appropriate content', 'info');
            
            const emptyRooms = Object.entries(allRooms).filter(([id, r]) => 
                (!r.npcs || r.npcs.length === 0) && 
                (!r.monsterSpawns || r.monsterSpawns.length === 0) &&
                (!r.items || r.items.length === 0)
            );

            log(`Found ${emptyRooms.length} empty rooms to populate`, 'info');

            let updated = 0;
            for (const [roomId, room] of emptyRooms) {
                const updates = analyzeAndPopulate(roomId, room);
                
                if (updates.npcs.length > 0 || updates.monsterSpawns.length > 0 || updates.items.length > 0) {
                    try {
                        const response = await fetch(`${MYSQL_API_URL}/rooms/${roomId}`, {
                            method: 'PATCH',
                            headers: getHeaders(),
                            body: JSON.stringify(updates)
                        });
                        
                        if (response.ok) {
                            log(`‚úì Updated: ${room.name || roomId}`, 'success');
                            updated++;
                        } else {
                            log(`‚ö†Ô∏è Failed to update: ${roomId}`, 'warning');
                        }
                    } catch (error) {
                        log(`‚ùå Error updating ${roomId}: ${error.message}`, 'error');
                    }
                    
                    // Rate limiting - wait a bit between requests
                    await new Promise(r => setTimeout(r, 100));
                }
            }

            log(`‚úÖ Population complete! Updated ${updated} rooms.`, 'success');
            await analyzeRooms(); // Refresh stats
        };

        function analyzeAndPopulate(roomId, room) {
            const name = (room.name || '').toLowerCase();
            const desc = (room.description || '').toLowerCase();
            const combined = name + ' ' + desc;

            const updates = {
                npcs: [],
                monsterSpawns: [],
                items: []
            };

            // Get available IDs from existing content
            const availableNpcs = Object.keys(allNPCs);
            const availableMonsters = Object.keys(allMonsters);
            const availableItems = Object.keys(allItems);

            // Helper function to check if NPC exists
            const hasNpc = (id) => availableNpcs.includes(id);
            const hasMonster = (id) => availableMonsters.includes(id);
            const hasItem = (id) => availableItems.includes(id);

            // NPCs based on room type (only add if they exist)
            if (combined.includes('shop') || combined.includes('store') || combined.includes('merchant')) {
                if (hasNpc('merchant-general')) updates.npcs.push('merchant-general');
                else if (hasNpc('frank')) updates.npcs.push('frank');
            }
            if (combined.includes('guard') || combined.includes('barracks') || combined.includes('tower')) {
                if (hasNpc('guard-town')) updates.npcs.push('guard-town');
            }
            if (combined.includes('temple') || combined.includes('shrine') || combined.includes('church')) {
                if (hasNpc('priest-wandering')) updates.npcs.push('priest-wandering');
            }
            if (combined.includes('library') || combined.includes('study')) {
                if (hasNpc('scholar')) updates.npcs.push('scholar');
                else if (hasNpc('mysterious-wizard')) updates.npcs.push('mysterious-wizard');
            }
            if (combined.includes('inn') || combined.includes('tavern')) {
                if (hasNpc('innkeeper')) updates.npcs.push('innkeeper');
                else if (hasNpc('barman')) updates.npcs.push('barman');
            }
            if (combined.includes('smithy') || combined.includes('forge') || combined.includes('blacksmith')) {
                if (hasNpc('bronson')) updates.npcs.push('bronson');
                else if (hasNpc('apprentice')) updates.npcs.push('apprentice');
            }
            if (combined.includes('hermit') || (combined.includes('cave') && Math.random() > 0.7)) {
                if (hasNpc('hermit')) updates.npcs.push('hermit');
            }
            if (combined.includes('beggar') || combined.includes('alley') || combined.includes('slum')) {
                if (hasNpc('beggar')) updates.npcs.push('beggar');
            }
            if (combined.includes('mine') || combined.includes('quarry')) {
                if (hasNpc('miner')) updates.npcs.push('miner');
            }
            if (combined.includes('graveyard') || combined.includes('cemetery')) {
                if (hasNpc('old_man')) updates.npcs.push('old_man');
            }
            
            // Add random NPCs for generic locations
            if (updates.npcs.length === 0 && availableNpcs.length > 0 && Math.random() > 0.85) {
                // 15% chance to add a random NPC to any room
                const randomNpc = availableNpcs[Math.floor(Math.random() * availableNpcs.length)];
                updates.npcs.push(randomNpc);
            }

            // Monsters based on environment (only add if they exist)
            if (combined.includes('sewer') || combined.includes('cellar') || combined.includes('basement')) {
                if (hasMonster('rat')) updates.monsterSpawns.push({ monsterId: 'rat', respawnTime: 120000 });
                if (hasMonster('giant-rat')) updates.monsterSpawns.push({ monsterId: 'giant-rat', respawnTime: 180000 });
            }
            if (combined.includes('forest') || combined.includes('woods')) {
                if (hasMonster('wolf')) updates.monsterSpawns.push({ monsterId: 'wolf', respawnTime: 200000 });
                if (hasMonster('goblin') && Math.random() > 0.5) updates.monsterSpawns.push({ monsterId: 'goblin', respawnTime: 240000 });
            }
            if (combined.includes('cave') || combined.includes('cavern') || combined.includes('grotto')) {
                if (hasMonster('bat')) updates.monsterSpawns.push({ monsterId: 'bat', respawnTime: 150000 });
                if (hasMonster('spider')) updates.monsterSpawns.push({ monsterId: 'spider', respawnTime: 200000 });
            }
            if (combined.includes('dungeon') || combined.includes('crypt') || combined.includes('tomb')) {
                if (hasMonster('skeleton')) updates.monsterSpawns.push({ monsterId: 'skeleton', respawnTime: 180000 });
                if (hasMonster('zombie') && Math.random() > 0.6) updates.monsterSpawns.push({ monsterId: 'zombie', respawnTime: 220000 });
            }
            if (combined.includes('bandit') || combined.includes('hideout') || combined.includes('camp')) {
                if (hasMonster('bandit')) updates.monsterSpawns.push({ monsterId: 'bandit', respawnTime: 240000 });
            }
            if (combined.includes('swamp') || combined.includes('bog') || combined.includes('marsh')) {
                if (hasMonster('zombie')) updates.monsterSpawns.push({ monsterId: 'zombie', respawnTime: 200000 });
            }
            if (combined.includes('mountain') || combined.includes('peak') || combined.includes('cliff')) {
                if (hasMonster('troll') && Math.random() > 0.7) updates.monsterSpawns.push({ monsterId: 'troll', respawnTime: 300000 });
            }
            if (combined.includes('haunted') || combined.includes('spirit') || combined.includes('ghost')) {
                if (hasMonster('ghost')) updates.monsterSpawns.push({ monsterId: 'ghost', respawnTime: 250000 });
                if (hasNpc('spirit-guardian')) updates.npcs.push('spirit-guardian');
            }
            if (combined.includes('demon') || combined.includes('hell') || combined.includes('infernal')) {
                if (hasMonster('demon')) updates.monsterSpawns.push({ monsterId: 'demon', respawnTime: 300000 });
            }
            if (combined.includes('dragon') || combined.includes('wyrm') || combined.includes('lair')) {
                if (hasMonster('dragon-wyrmling')) updates.monsterSpawns.push({ monsterId: 'dragon-wyrmling', respawnTime: 400000 });
            }

            // Items based on environment (only add if they exist)
            if (combined.includes('treasure') || combined.includes('vault') || combined.includes('hoard')) {
                if (hasItem('gold-coins')) updates.items.push('gold-coins');
                if (hasItem('gem-ruby')) updates.items.push('gem-ruby');
            }
            if (combined.includes('library') || combined.includes('study')) {
                if (hasItem('scroll')) updates.items.push('scroll');
                else if (hasItem('dusty-tome')) updates.items.push('dusty-tome');
            }
            if (combined.includes('armory') || combined.includes('weapon')) {
                if (hasItem('iron-sword')) updates.items.push('iron-sword');
                if (hasItem('leather-armor')) updates.items.push('leather-armor');
            }
            if (combined.includes('alchemist') || combined.includes('apothecary')) {
                if (hasItem('health-potion')) updates.items.push('health-potion');
                if (hasItem('mana-potion')) updates.items.push('mana-potion');
            }
            if (combined.includes('mine') || combined.includes('quarry')) {
                if (hasItem('crystal')) updates.items.push('crystal');
            }

            return updates;
        }

        window.populateAllRooms = async function() {
            if (!confirm('‚ö†Ô∏è WARNING: This will add content to ALL 182 rooms, even those with existing content. Are you sure?')) {
                return;
            }

            log('Force populating ALL rooms...', 'warning');
            
            let updated = 0;
            for (const [roomId, room] of Object.entries(allRooms)) {
                const updates = analyzeAndPopulate(roomId, room);
                
                if (updates.npcs.length > 0 || updates.monsterSpawns.length > 0 || updates.items.length > 0) {
                    try {
                        // Merge with existing content
                        const mergedUpdates = {
                            npcs: [...new Set([...(room.npcs || []), ...updates.npcs])],
                            monsterSpawns: [...(room.monsterSpawns || []), ...updates.monsterSpawns],
                            items: [...new Set([...(room.items || []), ...updates.items])]
                        };

                        const response = await fetch(`${MYSQL_API_URL}/rooms/${roomId}`, {
                            method: 'PATCH',
                            headers: getHeaders(),
                            body: JSON.stringify(mergedUpdates)
                        });
                        
                        if (response.ok) {
                            log(`‚úì Updated: ${room.name || roomId}`, 'success');
                            updated++;
                        }
                    } catch (error) {
                        log(`‚ùå Error: ${error.message}`, 'error');
                    }
                    
                    await new Promise(r => setTimeout(r, 100));
                }
            }

            log(`‚úÖ Complete! Updated ${updated} rooms.`, 'success');
            await analyzeRooms();
        };

        log('Ready! Start by clicking "Load & Analyze All Rooms from MySQL"', 'success');
    </script>
</body>
</html>
